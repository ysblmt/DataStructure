# 一 交换排序
## 1.1 冒泡排序
>思想：* 比较相邻元素，若第一个元素大于第二个，则交换  
	   * 对每一对相邻元素作同样工作，那么最后元素会最大
**优点**：  
	- 思路简单，代码简单，稳定  
**缺点**：  
	- 适合小数据排序，不适于大数据量排序(算法复杂度高)  
## 1.2 快速排序
>思想：* 从数列中挑出一个元素，成为“基准(pivot)”
	   * 所有比基准小的放在前面，所有比基准大的放在后面，分区之后，基准位于中间位置
	   * 递归执行数列排序  
**优点**：
	- 在大数据量下性能优越
**缺点**：  
	- 稳定性不高(无法保证相等数据按顺序被扫描和存放)  

# 二 插入排序
## 2.1 直接插入
>思想：* 把待排序的数组分成已排序和未排序两部分，初始的时候把第一个元素认为是已排好序的  
	   * 从第二个元素开始，在已排好序的子数组中寻找到该元素合适的位置并插入该位置
	   * 重复上述过程直到最后一个元素被插入有序子数组中  
**优点**：  
	- 稳定  
**缺点**：  
	- 数据较大不适用  
## 2.2 希尔排序
>思想：* 选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1
	   * 按增量序列个数k，对序列进行 k 趟排序
	   * 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m的子序列，分别对各子表进行直接插入排序。仅增量因子为1时，整个序列作为一个表来处理，表长度即为整个序列的长度
**优点**：  
	- 快速  
**缺点**：  
	- 不稳定  

# 三 选择排序  
## 3.1 直接选择
>思想：* 在未排序序列中找到最小（大）元素，存放到排序序列的起始位置  
	   * 从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾  
	   * 重复第二步，直到所有元素均排序完毕
**优点**：  
	- 数组实现不稳定，链表实现稳定  
	- 复杂度波动小，优于冒泡排序  
**缺点**：  
	- 时间复杂度高，只适用于简单数据排序  
## 3.2 堆排序
>堆排序就是把最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大数取出，这个过程持续到剩余数只有一个时结束。在堆中定义以下几种操作：
	* 最大堆调整（Max-Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点
	* 创建最大堆（Build-Max-Heap）：将堆所有数据重新排序，使其成为最大堆
	* 堆排序（Heap-Sort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算 继续进行下面的讨论前，需要注意的一个问题是：数组都是 Zero-Based，这就意味着我们的堆数据结构模型要发生改变
**优点**：  
	- 元素较多时，解决如“前n大的数”时，为首选算法
**缺点**：  
	- 开销过大  

# 四 归并排序
>思想：
    *递归法(Top-down)*  
    * 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列  
	* 设定两个指针，最初位置分别为两个已经排序序列的起始位置  
	* 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置  
	* 重复步骤3直到某一指针到达序列尾  
	* 将另一序列剩下的所有元素直接复制到合并序列尾  
    *迭代法(Bottom-up)*  
	(假设序列共有n个元素)  
    * 将序列每相邻两个数字进行归并操作，形成ceil(n/2)个序列，排序后每个序列包含两/一个元素  
	* 若此时序列数不是1个则将上述序列再次归并，形成ceil(n/4)个序列，每个序列包含四/三个元素  
	* 重复步骤2，直到所有元素排序完毕，即序列数为1  
**优点**：  
	- 稳定，在数据量大时效率高  
**缺点**：  
	- 占用内存  

# 五 计数排序
## 5.1 计数排序
>思想：* 找出待排序的数组中最大和最小的元素
	   * 统计数组中每个值为i的元素出现的次数，存入数组C的第i项
	   * 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）
	   * 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1
**优缺性**：  
	- 稳定；占用空间大








